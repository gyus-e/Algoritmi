class BreadthIterator
{
	Grafo G
	Node curr

	Queue Q
	int idx

	Vector color
}

BreadthIterator (grafo)
{
	G = grafo

	if (G.V.Size() == 0)
	{
		throw exception
	}

	InitColor () 

	curr = V[0]
	Q.Enqueue(curr)
	color[curr] = gray
	
	idx = 1
}

Operator++ ()
{	
	if (!Q.Empty())
	{
		u = Q.HeadNDequeue()
		
		for each v in G.Adj[u]
		{
			if (color[v] == white) 
			{
				Q.Enqueue(v)
				color[v] = gray
			}
		}
		
		color[u] = black
	}		
	
	//Se la coda è vuota ma l'iteratore non è terminato
	else if (!Terminated())
	{
		//devo scegliere la prossima sorgente dal vettore dei vertici
		//si parte da idx
		i = idx
		while (i < G.V.Size())
		{
			v = G.V[i]
			i++

			if (color[v] == white) 
			{
				Q.Enqueue(v)
				color[v] = gray
				
				//quando ho trovato una radice di ricerca posso uscire dal for
				break
			}
		}	
		
		idx = i //la prossima ricerca partirá da i
	}

	//bisogna controllare di nuovo se la coda è vuota (potrebbe essere stato fatto un dequeue) o l'iteratore è terminato (idx potrebbe aver raggiunto V.Size())
	if (Q.Empty() && Terminated()) 
	{
		throw exception
	}

	curr = Q.Head()
}

Operator* ()
{
	return curr
}

Terminated()
{
	return idx >= G.V.Size()
}

Reset ()
{
	Q.Clear()
	InitColor()

	curr = V[0]
	Q.Enqueue(curr)
	color[curr] = gray
	idx = 1
}

InitColor ()
{
	for i = 0; i < G.V.Size(); i++
	{
		color[i] = white
	}
}