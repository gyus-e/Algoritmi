BreadthIterator
{
	Queue Q = NIL
	int idx = 0
}

BreadthIterator (G)
{
	if (G.Size() == 0)
	{
		throw exception;
	}

	color = Init (G) 

	s = V[0];
	Q.Enqueue(s)
	color[s] = gray;
	
	idx = 1;
}

Operator++ ()
{	
	if (!Q.Empty())
	{
		u = Q.HeadNDequeue()
		
		for each v in Adj[u]
		{
			if (color[v] == white) 
			{
				Q.Enqueue(v);
				color[v] = gray;
			}
		}
		
		color[u] = black
	}		
	
	//Se la coda è vuota ma l'iteratore non è terminato
	else if (!Terminated(G))
	{
		//devo scegliere la prossima sorgente dal vettore dei vertici
		//si parte da idx
		for (i = idx; i < |V|; i++)
		{
			v = V[i];
			if (color[v] == white) 
			{
				Q.Enqueue(v);
				color[v] = gray;
				
				//quando ho trovato una radice di ricerca posso uscire dal for
				break; 
			}
		}	
		
		idx = i+1; //la prossima ricerca partirá da idx
	}

	//La coda è vuota e l'iteratore è terminato
	else 
	{
		throw exception;
	}
	
}

Terminated(G)
{
	return idx >= G.Size();
}